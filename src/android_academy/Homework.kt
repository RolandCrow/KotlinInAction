package android_academy

import kotlin.math.max
import kotlin.math.min
import kotlin.math.sqrt

fun main() {
    /**
     * Тривиальная
     *
     * Пользователь задает угол в градусах, минутах и секундах (например, 36 градусов 14 минут 35 секунд).
     * Вывести значение того же угла в радианах (например, 0.63256).
     */
    fun angleInRadian(grad: Int, min: Int, sec: Int): Double {


        val oneMinToGrad = (1/60)
        val oneSecToGrad = (1/3600)

        val allGrad = 36 + (14 * oneMinToGrad) + (35 * oneSecToGrad)

        return allGrad * 0.0174533
    }

    println(angleInRadian(36,14,35))


    /**
     * Тривиальная
     *
     * Найти длину отрезка, соединяющего точки на плоскости с координатами (x1, y1) и (x2, y2).
     * Например, расстояние между (3, 0) и (0, 4) равно 5
     */
    fun trackLength(x1: Double, y1: Double, x2: Double, y2: Double): Double {


        return kotlin.math.sqrt(((x2 - x1)*(x2 - x1)) + ((y2 - y1) * (y2 - y1)) )

    }

    println(trackLength(3.0,0.0, 0.0, 4.0))

    /**
     * Простая
     *
     * Пользователь задает целое число, большее 100 (например, 3801).
     * Определить третью цифру справа в этом числе (в данном случае 8).
     */
    fun thirdDigit(number: Int): Int {
        val toDigit = (number/100)%100
        return toDigit.toString().substring(1).toInt()

    }

    println(thirdDigit(3801))

    /**
     * Простая
     *
     * Поезд вышел со станции отправления в h1 часов m1 минут (например в 9:25) и
     * прибыл на станцию назначения в h2 часов m2 минут того же дня (например в 13:01).
     * Определите время поезда в пути в минутах (в данном случае 216).
     */
    fun travelMinutes(hoursDepart: Int, minutesDepart: Int, hoursArrive: Int, minutesArrive: Int)
            : Int {
        val minutesDeparts = (hoursDepart * 60) + minutesDepart
        val minutesArrives = (hoursArrive * 60) + minutesArrive
        return minutesDeparts - minutesArrives

    }

    println(travelMinutes(13,1, 9,25))

    /**
     * Простая
     *
     * Человек положил в банк сумму в s рублей под p% годовых (проценты начисляются в конце года).
     * Сколько денег будет на счету через 3 года (с учётом сложных процентов)?
     * Например, 100 рублей под 10% годовых превратятся в 133.1 рубля
     */
    fun accountInThreeYears(initial: Int, percent: Int): Double {
        val hardPercent = (1 + percent) * 3.0
        return initial + hardPercent
    }

    println(accountInThreeYears(100,10))

    /**
     * Простая
     *
     * Пользователь задает целое трехзначное число (например, 478).
     * Необходимо вывести число, полученное из заданного перестановкой цифр в обратном порядке (например, 874).
     */
    fun numberRevert(number: Int): Int {
        val strNumber = number.toString().reversed()
        return strNumber.toInt()
    }

    println(numberRevert(238))


    /**
     * Простая
     *
     * Мой возраст. Для заданного 0 < n < 200, рассматриваемого как возраст человека,
     * вернуть строку вида: «21 год», «32 года», «12 лет».
     */
    fun ageDescription(age: Int): String = when (age){
        21 -> "21 год"
        32 -> "32 года"
        12 -> "12 лет"
        else -> "Не тот возраст"
    }

    /**
     * Простая
     *
     * Путник двигался t1 часов со скоростью v1 км/час, затем t2 часов — со скоростью v2 км/час
     * и t3 часов — со скоростью v3 км/час.
     * Определить, за какое время он одолел первую половину пути?
     */
    fun timeForHalfWay(t1: Double, v1: Double,
                       t2: Double, v2: Double,
                       t3: Double, v3: Double): Double {

        val allKm = ((t1 * v1) + (t2 * v2) + (t3 * v3) ) * 0.5
        val km1 = t1 * v1
        val km2 = t2 * v2
        val km3  = t3 * v3

        var timeOfHalf = 0.0

        timeOfHalf = when {
            allKm <= km1 -> {
                allKm / v1
            }
            allKm <= km1 + km2 -> {
                t1 + (allKm - km1) / v3
            }
            else -> {
                t1 + t2 + (allKm - km1 - km2) / v3
            }
        }
        return timeOfHalf


    }
    /**
     * Простая
     *
     * Нa шахматной доске стоят черный король и две белые ладьи (ладья бьет по горизонтали и вертикали).
     * Определить, не находится ли король под боем, а если есть угроза, то от кого именно.
     * Вернуть 0, если угрозы нет, 1, если угроза только от первой ладьи, 2, если только от второй ладьи,
     * и 3, если угроза от обеих ладей.
     * Считать, что ладьи не могут загораживать друг друга
     */
    fun whichRookThreatens(kingX: Int, kingY: Int,
                           rookX1: Int, rookY1: Int,
                           rookX2: Int, rookY2: Int): Int {
        return if ((kingX != rookX1) && (kingX != rookX2) && (kingY != rookY1) && (kingY != rookY2)) 0
        else if ((kingX == rookX1) && (kingX != rookX2) && (kingY == rookY1) && (kingY != rookY2)) 1
        else if ((kingX != rookX1) && (kingX == rookX2) && (kingY != rookY1) && (kingY == rookY2)) 2
        else 3

    }

    /**
     * Простая
     *
     * На шахматной доске стоят черный король и белые ладья и слон
     * (ладья бьет по горизонтали и вертикали, слон — по диагоналям).
     * Проверить, есть ли угроза королю и если есть, то от кого именно.
     * Вернуть 0, если угрозы нет, 1, если угроза только от ладьи, 2, если только от слона,
     * и 3, если угроза есть и от ладьи и от слона.
     * Считать, что ладья и слон не могут загораживать друг друга.
     */
    fun rookOrBishopThreatens(kingX: Int, kingY: Int,
                              rookX: Int, rookY: Int,
                              bishopX: Int, bishopY: Int): Int {
        return if((kingX != rookX) && (kingY != rookY) || (kingX != bishopX) && (kingY != bishopY)) 0
        else if((kingX == rookX) && (kingY == rookY) || (kingX != bishopX) && (kingY != bishopY)) 1
        else if((kingX != rookX) && (kingY != rookY) || (kingX == bishopX) && (kingY == bishopY)) 2
        else 3
    }


    fun sqr(x: Double) = x * x

    /**
     * Простая
     *
     * Треугольник задан длинами своих сторон a, b, c.
     * Проверить, является ли данный треугольник остроугольным (вернуть 0),
     * прямоугольным (вернуть 1) или тупоугольным (вернуть 2).
     * Если такой треугольник не существует, вернуть -1.
     */
    fun triangleKind(a: Double, b: Double, c: Double): Int {

        val x = max(a, b)
        val y = max(x, c)
        val z = sqr(y)
        val m = sqr(a + b + c - y)
        val n = 2*a*b*c/y
        return if((m - n < z)&&( a + b + c > 2 * y)) 2
        else if ((m - n > z)&&( a + b + c > 2 * y )) 0
        else if((m - n == z)&&( a + b + c > 2 * y)) 1
        else -1
    }




    /**
     * Средняя
     *
     * Даны четыре точки на одной прямой: A, B, C и D.
     * Координаты точек a, b, c, d соответственно, b >= a, d >= c.
     * Найти длину пересечения отрезков AB и CD.
     * Если пересечения нет, вернуть -1.
     */
    fun segmentLength(a: Int, b: Int, c: Int, d: Int): Int {
        var x = 0
        return if((a >= c) && (c < d) && (b <= d)) {
            b - c
        }
        else if((a == d) || (b == c)) {
            0
        }
        else if((c <= a) && (b <= d)) {
            b - a
        }
        else if((a <= c) && (d <= b)) {
            d - c
        }
        else if((c <= a) && (a < d) && (d <= b)) {
            d - a
        }
        else -1
    }



    /**
     * Простая
     *
     * Четырехзначное число назовем счастливым, если сумма первых двух ее цифр равна сумме двух последних.
     * Определить, счастливое ли заданное число, вернуть true, если это так.
     */
    fun isNumberHappy(number: Int): Boolean {
        return number/1000 + (number / 100) %10 == (number / 10)%10 + number % 10
    }

    /**
     * Простая
     *
     * На шахматной доске стоят два ферзя (ферзь бьет по вертикали, горизонтали и диагоналям).
     * Определить, угрожают ли они друг другу. Вернуть true, если угрожают.
     * Считать, что ферзи не могут загораживать друг друга.
     */
    fun queenThreatens(x1: Int, y1: Int, x2: Int, y2: Int): Boolean {
        return x1 == x2 || y1 == y2 || x1 + y1 == x2 + y2 || x1 - y1 == x2 - y2
    }


    /**
     * Простая
     *
     * Дан номер месяца (от 1 до 12 включительно) и год (положительный).
     * Вернуть число дней в этом месяце этого года по григорианскому календарю.
     */
    fun daysInMonth(month: Int, year: Int): Int {
        return if(month == 1 || month == 3||  month == 5 || month == 7 || month == 8 || month == 10 ||
                month == 12) {
            30
        } else if(year % 4 == 0 && year % 100 == 0 && year % 400 == 0 && month == 2) {
            29
        } else if(month == 2) {
            28
        } else {
            31
        }
    }

    println(daysInMonth(3, 2020))

    /**
     * Средняя
     *
     * Проверить, лежит ли окружность с центром в (x1, y1) и радиусом r1 целиком внутри
     * окружности с центром в (x2, y2) и радиусом r2.
     * Вернуть true, если утверждение верно
     */
    fun circleInside(x1: Double, y1: Double, r1: Double,
                     x2: Double, y2: Double, r2: Double): Boolean {
        val a = x1 - x2
        val b = y1 - y2
        val n = sqrt(a * a + b * b)
        return (r2 <= r1 + n)
    }

    /**
     * Средняя
     *
     * Определить, пройдет ли кирпич со сторонами а, b, c сквозь прямоугольное отверстие в стене со сторонами r и s.
     * Стороны отверстия должны быть параллельны граням кирпича.
     * Считать, что совпадения длин сторон достаточно для прохождения кирпича, т.е., например,
     * кирпич 4 х 4 х 4 пройдёт через отверстие 4 х 4.
     * Вернуть true, если кирпич пройдёт
     */
    fun brickPasses(a: Int, b: Int, c: Int, r: Int, s: Int): Boolean {
        val x = min(min(a,b),c)
        val y = max(max(a,b),c)
        val z  = a + b + c - x - y
        val n = max(r,s)
        val m = min(r,s)

        return ((x <= m) && (z <= n))

    }




    /**
     * Тривиальная
     *
     * Найти количество цифр в заданном числе n.
     * Например, число 1 содержит 1 цифру, 456 -- 3 цифры, 65536 -- 5 цифр.
     *
     * Использовать операции со строками в этой задаче запрещается.
     */
    fun digitNumber(n: Int): Int = TODO()

    /**
     * Простая
     *
     * Найти число Фибоначчи из ряда 1, 1, 2, 3, 5, 8, 13, 21, ... с номером n.
     * Ряд Фибоначчи определён следующим образом: fib(1) = 1, fib(2) = 1, fib(n+2) = fib(n) + fib(n+1)
     */
    fun fib(n: Int): Int = TODO()

    /**
     * Простая
     *
     * Для заданных чисел m и n найти наименьшее общее кратное, то есть,
     * минимальное число k, которое делится и на m и на n без остатка
     */
    fun lcm(m: Int, n: Int): Int = TODO()

    /**
     * Простая
     *
     * Для заданного числа n > 1 найти минимальный делитель, превышающий 1
     */
    fun minDivisor(n: Int): Int = TODO()

    /**
     * Простая
     *
     * Для заданного числа n > 1 найти максимальный делитель, меньший n
     */
    fun maxDivisor(n: Int): Int = TODO()

    /**
     * Простая
     *
     * Определить, являются ли два заданных числа m и n взаимно простыми.
     * Взаимно простые числа не имеют общих делителей, кроме 1.
     * Например, 25 и 49 взаимно простые, а 6 и 8 -- нет.
     */
    fun isCoPrime(m: Int, n: Int): Boolean = TODO()

    /**
     * Простая
     *
     * Для заданных чисел m и n, m <= n, определить, имеется ли хотя бы один точный квадрат между m и n,
     * то есть, существует ли такое целое k, что m <= k*k <= n.
     * Например, для интервала 21..28 21 <= 5*5 <= 28, а для интервала 51..61 квадрата не существует.
     */
    fun squareBetweenExists(m: Int, n: Int): Boolean = TODO()

    /**
     * Средняя
     *
     * Гипотеза Коллатца. Рекуррентная последовательность чисел задана следующим образом:
     *
     *   ЕСЛИ (X четное)
     *     Xслед = X /2
     *   ИНАЧЕ
     *     Xслед = 3 * X + 1
     *
     * например
     *   15 46 23 70 35 106 53 160 80 40 20 10 5 16 8 4 2 1 4 2 1 4 2 1 ...
     * Данная последовательность рано или поздно встречает X == 1.
     * Написать функцию, которая находит, сколько шагов требуется для
     * этого для какого-либо начального X > 0.
     */
    fun collatzSteps(x: Int): Int = TODO()

    /**
     * Средняя
     *
     * Для заданного x рассчитать с заданной точностью eps
     * sin(x) = x - x^3 / 3! + x^5 / 5! - x^7 / 7! + ...
     * Нужную точность считать достигнутой, если очередной член ряда меньше eps по модулю
     */
    fun sin(x: Double, eps: Double): Double = TODO()

    /**
     * Средняя
     *
     * Для заданного x рассчитать с заданной точностью eps
     * cos(x) = 1 - x^2 / 2! + x^4 / 4! - x^6 / 6! + ...
     * Нужную точность считать достигнутой, если очередной член ряда меньше eps по модулю
     */
    fun cos(x: Double, eps: Double): Double = TODO()

    /**
     * Средняя
     *
     * Поменять порядок цифр заданного числа n на обратный: 13478 -> 87431.
     *
     * Использовать операции со строками в этой задаче запрещается.
     */
    fun revert(n: Int): Int = TODO()

    /**
     * Средняя
     *
     * Проверить, является ли заданное число n палиндромом:
     * первая цифра равна последней, вторая -- предпоследней и так далее.
     * 15751 -- палиндром, 3653 -- нет.
     *
     * Использовать операции со строками в этой задаче запрещается.
     */
    fun isPalindrome(n: Int): Boolean = TODO()

    /**
     * Средняя
     *
     * Для заданного числа n определить, содержит ли оно различающиеся цифры.
     * Например, 54 и 323 состоят из разных цифр, а 111 и 0 из одинаковых.
     *
     * Использовать операции со строками в этой задаче запрещается.
     */
    fun hasDifferentDigits(n: Int): Boolean = TODO()

    /**
     * Сложная
     *
     * Найти n-ю цифру последовательности из квадратов целых чисел:
     * 149162536496481100121144...
     * Например, 2-я цифра равна 4, 7-я 5, 12-я 6.
     *
     * Использовать операции со строками в этой задаче запрещается.
     */
    fun squareSequenceDigit(n: Int): Int = TODO()

    /**
     * Сложная
     *
     * Найти n-ю цифру последовательности из чисел Фибоначчи (см. функцию fib выше):
     * 1123581321345589144...
     * Например, 2-я цифра равна 1, 9-я 2, 14-я 5.
     *
     * Использовать операции со строками в этой задаче запрещается.
     */
    fun fibSequenceDigit(n: Int): Int = TODO()



}